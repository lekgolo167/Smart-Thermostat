#include "Oled.hpp"

OLED::OLED(Adafruit_SSD1306 *display, tm *clk, History* history, thermostat_settings *settings, sensor_readings *sensor)
{
	m_settings = settings;
	m_sensor = sensor;
	m_time = clk;
	m_history = history;
	m_history->set_grid_scale(55.0, 18.0);
	m_display = display;
	m_display->setTextColor(SSD1306_WHITE);
	edit_oled_menu = false;
	oled_menu_item = 0;
	oled_menu_state = 8;
	oled_screen_ON = true;
	oled_scroll_counter = 0;
	m_furnace_runtime = 0;
	String s;
}

OLED::~OLED()
{
}

void OLED::update()
{

	if (!oled_screen_ON)
	{
		return;
	}

	switch (oled_menu_state)
	{
	case 0:
	{
		oled_draw_logo();
		break;
	}
	case 1:
	{
		menu_set_temperature();
		break;
	}
	case 2:
	{
		menu_sensor_data();
		break;
	}
	case 3:
	{
		menu_set_thresholds();
		break;
	}
	case 4:
	{
		menu_sample_settings();
		break;
	}
	case 5:
	{
		menu_motion_settings();
		break;
	}
	case 6:
	{
		menu_date_and_time();
		break;
	}
	case 7:
	{
		menu_current_cycle();
		break;
	}
	case 8:
	{
		draw_history_graph();
		break;
	}
	default:
	{
		if (oled_menu_state > 8)
		{
			oled_menu_state = 0;
		}
		else if (oled_menu_state < 0) {
			oled_menu_state = 8;
		}
		update();
		break;
	}
	}
}

void OLED::next_menu()
{
	if (oled_screen_ON)
	{
		oled_menu_state++;
		oled_scroll_counter = 0;
		edit_oled_menu = false;
		oled_menu_item = -1;
	}

	oled_screen_ON = true;
	update();
}

void OLED::previous_menu()
{
	if (oled_screen_ON)
	{
		oled_menu_state--;
		oled_scroll_counter = 0;
		edit_oled_menu = false;
		oled_menu_item = -1;
	}

	oled_screen_ON = true;
	update();
}

void OLED::edit()
{
	if (oled_screen_ON)
	{
		edit_oled_menu = !edit_oled_menu;

		if (edit_oled_menu)
		{ // If editing, get the corrisponding variable and copy it to a temporary variable
			update_temporary_setting_value();
		}
		else
		{ // If not editing set the temporary to the corrisponding var
			update_user_settings();
		}
	}

	oled_screen_ON = true;
	update();
}

void OLED::on()
{
	oled_screen_ON = true;
	update();
}

void OLED::off()
{
	oled_screen_ON = false;
	m_display->clearDisplay();
	m_display->display();
}

void OLED::rotary_dial(uint8_t direction)
{
	if (oled_screen_ON)
	{
		if (edit_oled_menu)
		{
			temporary_setting += direction;
		}
		else
		{
			oled_scroll_counter += direction;
		}
	}
	else
	{
		oled_screen_ON = true;
	}
	update();
}

void OLED::set_runtime(uint32_t runtime)
{
	m_furnace_runtime = runtime;
}

void OLED::menu_set_temperature()
{
	int8_t items[] = {-1, TARGET};

	// Clear OLED buffer
	m_display->clearDisplay();
	m_display->setTextSize(FONT_SIZE_TITLE);
	m_display->setCursor(0, 0);

	// Draw the title
	m_display->println("Edit Temp");

	// Convert temperature to string
	sprintf(buffer, "Air:%.1fF\367", m_sensor->temperature_F);
	// Draw room temperature label at line 1
	m_display->setCursor(1, OLED_LINE_1_Y);
	m_display->println(buffer);

	// Convert target temperature to string
	if (edit_oled_menu && oled_menu_item == TARGET)
	{
		sprintf(buffer, "Set:%d.0F\367", temporary_setting);
	}
	else
	{
		sprintf(buffer, "Set:%.1fF\367", m_settings->target_temperature);
	}

	// Draw target temperature at line 3
	m_display->setCursor(1, OLED_LINE_3_Y);
	m_display->println(buffer);

	// Confine the scroll line of the menu
	bound_scroll_counter(3, 3, 16);

	// Save which item we are editing
	oled_menu_item = items[(oled_scroll_counter - 2)];

	// Send the buffer to OLED RAM
	m_display->display();
}

void OLED::menu_sensor_data()
{
	// Clear OLED buffer
	m_display->clearDisplay();
	m_display->setTextSize(FONT_SIZE_TITLE);
	m_display->setCursor(0, 0);

	// Draw the title
	m_display->println("Sensors");
	m_display->setTextSize(FONT_SIZE_LINE);

	// Convert celcius temperature to string
	sprintf(buffer, "HDC1080:  %.1f C\367", m_sensor->temperature_C);

	// Draw celcius temperature at line 1
	m_display->setCursor(1, OLED_LINE_1_Y);
	m_display->println(buffer);

	// Convert fahrenheit temperature to string
	sprintf(buffer, "HDC1080:  %.1f F\367", m_sensor->temperature_F);

	// Draw fahrenheit temperature at line 2
	m_display->setCursor(1, OLED_LINE_2_Y);
	m_display->println(buffer);

	// Convert humidity to string
	sprintf(buffer, "Humidity: %.1f %%", m_sensor->humidity);

	// Draw humidity at line 3
	m_display->setCursor(1, OLED_LINE_3_Y);
	m_display->println(buffer);

	// Convert average temperature to string
	sprintf(buffer, "Average:  %.1f F\367", m_sensor->average_temperature);

	// Draw humidity at line 4
	m_display->setCursor(1, OLED_LINE_4_Y);
	m_display->println(buffer);

	// Send the buffer to OLED RAM
	m_display->display();
}

void OLED::menu_sample_settings()
{
	int8_t items[] = {-1, TOTALSAMPLES, SAMPLEPERIOD};

	// Clear OLED buffer
	m_display->clearDisplay();
	m_display->setTextSize(FONT_SIZE_TITLE);
	m_display->setCursor(0, 0);

	// Draw the title
	m_display->println("Settings");
	m_display->setTextSize(FONT_SIZE_LINE);

	// Switch between edited value and set value
	if (edit_oled_menu && oled_menu_item == TOTALSAMPLES)
	{
		sprintf(buffer, "Total Samples: %d", temporary_setting);
	}
	else
	{
		sprintf(buffer, "Total Samples: %d", m_settings->total_samples);
	}
	// Draw total samples at line 1
	m_display->setCursor(1, OLED_LINE_1_Y);
	m_display->println(buffer);

	// Switch between edited value and set value
	if (edit_oled_menu && oled_menu_item == SAMPLEPERIOD)
	{
		sprintf(buffer, "Sample Period: %ds", temporary_setting);
	}
	else
	{
		sprintf(buffer, "Sample Period: %ds", m_settings->sample_period_sec);
	}
	// Draw sample period in seconds at line 2
	m_display->setCursor(1, OLED_LINE_2_Y);
	m_display->println(buffer);

	// Confine the scroll line of the menu
	bound_scroll_counter(1, 2, 9);

	// Save which item we are editing
	oled_menu_item = items[oled_scroll_counter];

	// Send the buffer to OLED RAM
	m_display->display();
}

void OLED::menu_set_thresholds()
{
	int8_t items[] = {-1, THRESHOLDLOWER, THRESHOLDUPPER, BASELINE};

	// Clear OLED buffer
	m_display->clearDisplay();
	m_display->setTextSize(FONT_SIZE_TITLE);
	m_display->setCursor(0, 0);

	// Draw the title
	m_display->println("Settings");
	m_display->setTextSize(FONT_SIZE_LINE);
	// Switch between edited value and set value
	if (edit_oled_menu && oled_menu_item == THRESHOLDLOWER)
	{
		sprintf(buffer, "Thresh Lower:  %d.0 F\367", temporary_setting);
	}
	else
	{
		sprintf(buffer, "Thresh Lower:  %.1f F\367", m_settings->lower_threshold);
	}
	// Draw lower threshold at line 1
	m_display->setCursor(1, OLED_LINE_1_Y);
	m_display->println(buffer);

	// Switch between edited value and set value
	if (edit_oled_menu && oled_menu_item == THRESHOLDUPPER)
	{
		sprintf(buffer, "Thresh Upper:  %d.0 F\367", temporary_setting);
	}
	else
	{
		sprintf(buffer, "Thresh Upper:  %.1f F\367", m_settings->upper_threshold);
	}
	// Draw upper threshold at line 2
	m_display->setCursor(1, OLED_LINE_2_Y);
	m_display->println(buffer);

	// Switch between edited value and set value
	if (edit_oled_menu && oled_menu_item == BASELINE)
	{
		sprintf(buffer, "Baseline:     %d.0 F\367", temporary_setting);
	}
	else
	{
		sprintf(buffer, "Baseline:     %.1f F\367", m_settings->baseline_temperature);
	}

	// Draw baseline temperautre at line 3
	m_display->setCursor(1, OLED_LINE_3_Y);
	m_display->println(buffer);

	// Confine the scroll line of the menu
	bound_scroll_counter(1, 3, 9);

	// Save which item we are editing
	oled_menu_item = items[oled_scroll_counter];

	// Send the buffer to OLED RAM
	m_display->display();
}

void OLED::menu_motion_settings()
{
	int8_t items[] = {-1, SCREENTIMEOUT, OVERRIDE, MOTIONDETECTION};

	// Clear OLED buffer
	m_display->clearDisplay();
	m_display->setTextSize(FONT_SIZE_TITLE);
	m_display->setCursor(0, 0);

	// Draw the title
	m_display->println("Settings");
	m_display->setTextSize(FONT_SIZE_LINE);

	// Switch between edited value and set value
	if (edit_oled_menu && oled_menu_item == SCREENTIMEOUT)
	{
		sprintf(buffer, "Screen Timeout: %ds", temporary_setting);
	}
	else
	{
		sprintf(buffer, "Screen Timeout: %ds", m_settings->screen_timeout_millis / 1000);
	}
	// Draw a screen timeout at line 1
	m_display->setCursor(1, OLED_LINE_1_Y);
	m_display->println(buffer);

	// Switch between edited value and set value
	if (edit_oled_menu && oled_menu_item == OVERRIDE)
	{
		sprintf(buffer, "Override: %d min", temporary_setting);
	}
	else
	{
		// Also, covnert millis to minutes
		sprintf(buffer, "Override: %d min", m_settings->override_timeout_millis / (60 * 1000));
	}
	// Draw away time at line 2
	m_display->setCursor(1, OLED_LINE_2_Y);
	m_display->println(buffer);

	// Switch between edited value and set value
	if (edit_oled_menu && oled_menu_item == MOTIONDETECTION)
	{
		sprintf(buffer, "Away Time: %d hr", temporary_setting);
	}
	else
	{
		// Also, covnert millis to hours
		sprintf(buffer, "Away Time: %d hr", m_settings->motion_timeout_millis / (3600 * 1000));
	}
	// Draw away time at line 3
	m_display->setCursor(1, OLED_LINE_3_Y);
	m_display->println(buffer);

	// Confine the scroll line of the menu
	bound_scroll_counter(1, 3, 9);

	// Save which item we are editing
	oled_menu_item = items[oled_scroll_counter];

	// Send the buffer to OLED RAM
	m_display->display();
}

void OLED::menu_date_and_time()
{

	int8_t items[] = {-1, -1, SYNCRTC};

	// Clear OLED buffer
	m_display->clearDisplay();
	m_display->setTextSize(FONT_SIZE_TITLE);
	m_display->setCursor(0, 0);

	// Draw the title
	m_display->println("Time");
	m_display->setTextSize(FONT_SIZE_LINE);

	// Convert time into date string
	char *c = asctime(m_time);
	c[16] = ' ';

	c[17] = c[20];
	c[18] = c[21];
	c[19] = c[22];
	c[20] = c[23];

	c[21] = '\0';

	// Draw time/date on line 1
	m_display->setCursor(1, OLED_LINE_1_Y);
	m_display->println(c);

	// Draw sync option on line 2
	m_display->setCursor(1, OLED_LINE_2_Y);
	m_display->println("Sync RTC Time  'OK'");

	// Confine the scroll line of the menu
	bound_scroll_counter(2, 2, 9);

	// Save which item we are editing
	oled_menu_item = items[oled_scroll_counter];

	// Send the buffer to OLED RAM
	m_display->display();
}

void OLED::menu_current_cycle()
{
	// Clear OLED buffer
	m_display->clearDisplay();
	m_display->setTextSize(FONT_SIZE_TITLE);
	m_display->setCursor(0, 0);

	// Draw the title
	m_display->println("Cycle Info");
	m_display->setTextSize(FONT_SIZE_LINE);

	// Draw start time on line 1
	sprintf(buffer, "Start time %02d:%02d", m_settings->current_cycle->start_hour, m_settings->current_cycle->start_min);
	m_display->setCursor(1, OLED_LINE_1_Y);
	m_display->println(buffer);

	// Draw end time on line 2
	sprintf(buffer, "End time   %02d:%02d", m_settings->current_cycle->end_hour, m_settings->current_cycle->end_min);
	m_display->setCursor(1, OLED_LINE_2_Y);
	m_display->println(buffer);

	// Draw runtime on line 3
	sprintf(buffer, "Runtime %d min", m_furnace_runtime / 60);
	m_display->setCursor(1, OLED_LINE_3_Y);
	m_display->println(buffer);

	// Send the buffer to OLED RAM
	m_display->display();
}

void OLED::draw_history_graph()
{
	// Clear OLED buffer
	m_display->clearDisplay();
	m_display->setCursor(0, 0);

	// Draw the title
	m_display->setTextSize(FONT_SIZE_TITLE);
	m_display->print("History");
	m_display->setTextSize(FONT_SIZE_LINE);
	
	// Convert celcius temperature to string
	sprintf(buffer, " %.1fF\367", m_sensor->temperature_F);
	m_display->println(buffer);
	
	m_history->prepare_data();
	// Y-axis labels
	m_display->setCursor(0, 17);
	m_display->print((int16_t)m_history->get_max());
	m_display->setCursor(0, 48);
	m_display->print((int16_t)m_history->get_min());

	// X-axis labels
	int time_marker = (m_settings->sample_period_sec * m_history->m_length) / 60;
	m_display->setCursor(116, 57);
	m_display->print(0);
	m_display->setCursor(61, 57);
	m_display->print(time_marker >> 1);
	m_display->setCursor(13, 57);
	m_display->print(time_marker);
	m_display->drawFastHLine(12, 55, 112, WHITE);
	m_display->drawFastVLine(12, 17, 39, WHITE);

	for (int x = 13; x < m_history->m_length+13; x++) {
		int16_t y = m_history->get_datapoint();
		m_display->drawPixel(x, y, WHITE);
	}

	// Send the buffer to OLED RAM
	m_display->display();
}

void OLED::update_user_settings()
{
	switch (oled_menu_item)
	{
	case TARGET:
	{
		if (temporary_setting >= m_settings->baseline_temperature && temporary_setting <= 95)
		{
			m_settings->target_temperature = temporary_setting;
			global_msg_queue->push(START_TEMPORARY_OVERRIDE);
			global_msg_queue->push(SEND_SERVER_STATS);
		}
	}
	break;
	case THRESHOLDLOWER:
	{
		if (temporary_setting >= 0 && temporary_setting <= 5)
		{
			m_settings->lower_threshold = temporary_setting;
			global_msg_queue->push(SEND_SERVER_STATS);
		}
	}
	break;
	case THRESHOLDUPPER:
	{
		if (temporary_setting >= 0 && temporary_setting <= 5)
		{
			m_settings->upper_threshold = temporary_setting;
			global_msg_queue->push(SEND_SERVER_STATS);
		}
	}
	break;
	case BASELINE:
	{
		if (temporary_setting >= 45 && temporary_setting <= 60)
			m_settings->baseline_temperature = temporary_setting;
	}
	break;
	case TOTALSAMPLES:
	{
		if (temporary_setting >= 1 && temporary_setting <= 20)
			m_settings->total_samples = temporary_setting;
		global_msg_queue->push(UPDATE_SAMPLE_SUM);
	}
	break;
	case SAMPLEPERIOD:
	{
		if (temporary_setting >= 5 && temporary_setting <= 300)
		{
			m_settings->sample_period_sec = temporary_setting;
			global_msg_queue->push(UPDATE_SAMPLE_PERIOD);
		}
	}
	break;
	case SCREENTIMEOUT:
	{
		if (temporary_setting >= 1 && temporary_setting <= 180)
			m_settings->screen_timeout_millis = temporary_setting * 1000;
	}
	break;
	case MOTIONDETECTION:
	{
		if (temporary_setting >= 6 && temporary_setting <= 96)
			m_settings->motion_timeout_millis = temporary_setting * 3600 * 1000; // convert to milliseconds from hours
	}
	case OVERRIDE:
	{
		if (temporary_setting >= 15 && temporary_setting <= 180)
			m_settings->override_timeout_millis = temporary_setting * 60 * 1000; // convert to milliseconds from minutes
	}
	break;
	default:
		break;
	}
}

void OLED::update_temporary_setting_value()
{
	switch (oled_menu_item)
	{
	case TARGET:
	{
		temporary_setting = m_settings->target_temperature;
	}
	break;
	case THRESHOLDLOWER:
	{
		temporary_setting = m_settings->lower_threshold;
	}
	break;
	case THRESHOLDUPPER:
	{
		temporary_setting = m_settings->upper_threshold;
	}
	break;
	case BASELINE:
	{
		temporary_setting = m_settings->baseline_temperature;
	}
	break;
	case TOTALSAMPLES:
	{
		temporary_setting = m_settings->total_samples;
	}
	break;
	case SAMPLEPERIOD:
	{
		temporary_setting = m_settings->sample_period_sec;
	}
	break;
	case SCREENTIMEOUT:
	{
		temporary_setting = m_settings->screen_timeout_millis / 1000; // convert from millis to seconds
	}
	break;
	case MOTIONDETECTION:
	{
		temporary_setting = m_settings->motion_timeout_millis / (3600 * 1000); // convert from millis to hours
	}
	break;
	case OVERRIDE:
	{
		temporary_setting = m_settings->override_timeout_millis / (60 * 1000); // convert from millis to minutes
	}
	break;
	case SYNCRTC:
	{
		global_msg_queue->push(GET_EPOCH);
		global_msg_queue->push(RTC_UPDATE);
	}
	break;
	default:
		break;
	}
}

void OLED::bound_scroll_counter(int8_t low, int8_t high, uint8_t height)
{
	if (oled_scroll_counter > high)
	{
		oled_scroll_counter = high;
	}
	else if (oled_scroll_counter < low - 1)
	{
		oled_scroll_counter = low - 1;
	}
	if (oled_scroll_counter >= low)
		m_display->fillRect(0, line_selection[oled_scroll_counter] - 1, SCREEN_WIDTH, height, SSD1306_INVERSE);
}

int8_t OLED::line_selection[] = {-20, OLED_LINE_1_Y, OLED_LINE_2_Y, OLED_LINE_3_Y, OLED_LINE_4_Y};

// AVNET logoS
static const uint8_t logo_ordered_dither[1024] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0xbb, 0xbb, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x55, 0x55, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xaf, 0xef, 0xef, 0xee, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x02, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xa0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x54, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0x80, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x02, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xa8, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x05, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x54, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x2f, 0xff, 0xef, 0xea, 0x88, 0x88, 0xab, 0xef, 0xef, 0xfe, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x15, 0x55, 0x55, 0x40, 0x00, 0x00, 0x01, 0x41, 0x55, 0x55, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xbb, 0xbb, 0xba, 0xa0, 0x00, 0x00, 0x02, 0xa2, 0xfb, 0xbb, 0xa0, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x55, 0x55, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x0a, 0xff, 0xff, 0xe8, 0x00, 0x00, 0x00, 0x08, 0x88, 0xbf, 0xff, 0xe8, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x55, 0x50, 0x00, 0x00, 
0x00, 0x00, 0x0b, 0xbb, 0xba, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x2b, 0xbb, 0xb8, 0x00, 0x00, 
0x00, 0x00, 0x05, 0x55, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x54, 0x00, 0x00, 
0x00, 0x00, 0x0f, 0xff, 0xe8, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88, 0x8a, 0xef, 0xee, 0x00, 0x00, 
0x00, 0x00, 0x15, 0x55, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x55, 0x54, 0x00, 0x00, 
0x00, 0x00, 0x2b, 0xbb, 0xa0, 0x00, 0x00, 0x02, 0x22, 0x22, 0x22, 0x00, 0xbb, 0xba, 0x00, 0x00, 
0x00, 0x00, 0x15, 0x55, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x54, 0x00, 0x00, 
0x00, 0x00, 0x2f, 0xff, 0x80, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x08, 0xff, 0xfe, 0x80, 0x00, 
0x00, 0x00, 0x15, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x55, 0x00, 0x00, 
0x00, 0x00, 0x2b, 0xbb, 0x80, 0x00, 0x02, 0xa2, 0x22, 0x22, 0x2a, 0x22, 0x0b, 0xba, 0x00, 0x00, 
0x00, 0x00, 0x15, 0x55, 0x40, 0x00, 0x01, 0x40, 0x00, 0x00, 0x04, 0x00, 0x15, 0x54, 0x00, 0x00, 
0x00, 0x00, 0x2f, 0xef, 0x80, 0x08, 0x8a, 0x88, 0x88, 0x88, 0x88, 0x88, 0xbf, 0xee, 0x00, 0x00, 
0x00, 0x00, 0x15, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 
0x00, 0x00, 0x3b, 0xbb, 0xa2, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x23, 0xbb, 0xba, 0x00, 0x00, 
0x00, 0x00, 0x55, 0x55, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x55, 0x55, 0x00, 0x00, 
0x00, 0x00, 0xbf, 0xfe, 0x88, 0x88, 0xa8, 0x88, 0xa8, 0x88, 0xa8, 0xa2, 0xff, 0xff, 0xa0, 0x00, 
0x00, 0x01, 0x55, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x55, 0x55, 0x40, 0x00, 
0x00, 0x03, 0xbf, 0xa2, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x03, 0xbb, 0xbb, 0xa0, 0x00, 
0x00, 0x05, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x55, 0x50, 0x00, 
0x00, 0x0f, 0xe8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x2f, 0xef, 0xeb, 0xe8, 0x00, 
0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x55, 0x00, 0x50, 0x00, 
0x00, 0x02, 0x00, 0x2a, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0xbb, 0xba, 0x80, 0x20, 0x00, 
0x00, 0x00, 0x00, 0x15, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x54, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xaa, 0xa8, 0xa8, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xff, 0xe8, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x40, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x02, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x2b, 0xbb, 0xa0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x40, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0xaf, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x55, 0x40, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3a, 0xbb, 0xa0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x55, 0x40, 0x00, 0x00, 0x00, 
0x00, 0x08, 0xa8, 0x88, 0xa8, 0x88, 0xa8, 0x88, 0xa8, 0x88, 0x80, 0xbf, 0xe0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x40, 0x00, 0x00, 0x00, 
0x00, 0x02, 0x02, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x0b, 0xa0, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x40, 0x00, 0x00, 0x00, 
0x00, 0x02, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x0b, 0x80, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x02, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xa8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x02, 0x02, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x0a, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xa2, 0x22, 0x22, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t thunder_cloud [288] {
0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 
0x00, 0x07, 0xff, 0x80, 0x00, 0x00, 
0x00, 0x0f, 0xff, 0xc0, 0x00, 0x00, 
0x00, 0x1f, 0xff, 0xe0, 0x00, 0x00, 
0x00, 0x3f, 0x03, 0xff, 0xf0, 0x00, 
0x00, 0x7c, 0x00, 0xff, 0xfc, 0x00, 
0x00, 0xf8, 0x00, 0x7f, 0xfe, 0x00, 
0x00, 0xf0, 0x00, 0x3e, 0x7f, 0x00, 
0x00, 0xf0, 0x00, 0x38, 0x1f, 0x00, 
0x01, 0xe0, 0x00, 0x00, 0x0f, 0x80, 
0x03, 0xe0, 0x00, 0x00, 0x07, 0xe0, 
0x0f, 0xe0, 0x00, 0x00, 0x07, 0xf0, 
0x1f, 0xe0, 0x00, 0x00, 0x03, 0xf8, 
0x3f, 0x00, 0x00, 0x00, 0x00, 0xfc, 
0x3c, 0x00, 0x00, 0x00, 0x00, 0x3e, 
0x78, 0x00, 0x00, 0x00, 0x00, 0x1e, 
0x78, 0x00, 0x00, 0x00, 0x00, 0x1e, 
0x70, 0x00, 0x00, 0x00, 0x00, 0x0f, 
0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 
0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 
0xf0, 0x00, 0x00, 0x00, 0x00, 0x0e, 
0x78, 0x00, 0x00, 0x00, 0x00, 0x1e, 
0x78, 0x00, 0x00, 0x00, 0x00, 0x3e, 
0x7c, 0x00, 0x00, 0x00, 0x00, 0x3c, 
0x3f, 0x00, 0x00, 0x01, 0xf8, 0x38, 
0x1f, 0xe0, 0x00, 0x03, 0xf0, 0x00, 
0x0f, 0xf0, 0x00, 0x03, 0xe0, 0x00, 
0x07, 0xf0, 0x00, 0x07, 0xe0, 0x00, 
0x01, 0xf8, 0x00, 0x07, 0xc0, 0x3e, 
0x00, 0x7c, 0x00, 0x07, 0x80, 0x7e, 
0x00, 0x3e, 0x07, 0x0f, 0x80, 0x7c, 
0x00, 0x3f, 0xff, 0x8f, 0xf8, 0xfc, 
0x00, 0x1f, 0xff, 0x9f, 0xf0, 0xf8, 
0x00, 0x07, 0xfe, 0x1f, 0xe1, 0xf0, 
0x00, 0x03, 0xfc, 0x3f, 0xe1, 0xf0, 
0x00, 0x00, 0x00, 0x03, 0xc1, 0xff, 
0x00, 0x00, 0x00, 0x03, 0x83, 0xfe, 
0x00, 0x00, 0x00, 0x03, 0x83, 0xfc, 
0x00, 0x00, 0x00, 0x07, 0x07, 0xfc, 
0x00, 0x00, 0x00, 0x06, 0x00, 0x78, 
0x00, 0x00, 0x00, 0x06, 0x00, 0x70, 
0x00, 0x00, 0x00, 0x04, 0x00, 0x70, 
0x00, 0x00, 0x00, 0x08, 0x00, 0xe0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t partly_cloudy [288] {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 
0x04, 0x01, 0x80, 0x10, 0x00, 0x00, 
0x0e, 0x01, 0x80, 0x30, 0x00, 0x00, 
0x07, 0x00, 0x80, 0x70, 0x00, 0x00, 
0x03, 0x80, 0x00, 0xe0, 0x00, 0x00, 
0x01, 0xc0, 0x81, 0xc0, 0x00, 0x00, 
0x00, 0xc7, 0xf1, 0x00, 0x00, 0x00, 
0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 
0x00, 0x38, 0x1c, 0x38, 0x00, 0x00, 
0x00, 0x30, 0x01, 0xff, 0x00, 0x00, 
0x00, 0x60, 0x03, 0xe7, 0xc0, 0x00, 
0x00, 0x60, 0x07, 0x00, 0xe0, 0x00, 
0xfc, 0x60, 0x0e, 0x00, 0x70, 0x00, 
0xfe, 0x60, 0x1c, 0x00, 0x30, 0x00, 
0x00, 0x60, 0x18, 0x00, 0x18, 0x00, 
0x00, 0x60, 0x18, 0x00, 0x1f, 0xc0, 
0x00, 0x70, 0x30, 0x00, 0x1f, 0xf0, 
0x00, 0x38, 0x30, 0x00, 0x18, 0x38, 
0x00, 0x1c, 0x30, 0x00, 0x00, 0x1c, 
0x00, 0x0c, 0x70, 0x00, 0x00, 0x0e, 
0x00, 0xc1, 0xf8, 0x00, 0x00, 0x06, 
0x01, 0xc3, 0x80, 0x00, 0x00, 0x03, 
0x03, 0x87, 0x00, 0x00, 0x00, 0x03, 
0x07, 0x06, 0x00, 0x00, 0x00, 0x03, 
0x06, 0x06, 0x00, 0x00, 0x00, 0x03, 
0x00, 0x0c, 0x00, 0x00, 0x00, 0x03, 
0x00, 0x0e, 0x00, 0x00, 0x00, 0x07, 
0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 
0x00, 0x06, 0x00, 0x00, 0x00, 0x0e, 
0x00, 0x03, 0x00, 0x00, 0x00, 0x1c, 
0x00, 0x03, 0xff, 0xff, 0xff, 0xf8, 
0x00, 0x00, 0xff, 0xff, 0xff, 0xe0, 
0x00, 0x00, 0x1f, 0xff, 0xff, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 
0x00, 0x00, 0x1c, 0x00, 0x03, 0x00, 
0x00, 0x00, 0x18, 0x00, 0x07, 0x00, 
0x00, 0x00, 0x30, 0x00, 0x0e, 0x00, 
0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t snow_cloudy [288] {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 
0x00, 0x00, 0x07, 0xff, 0x00, 0x00, 
0x00, 0x00, 0x1e, 0x03, 0x80, 0x00, 
0x00, 0x00, 0x18, 0x01, 0xc0, 0x00, 
0x00, 0x00, 0x30, 0x00, 0xe0, 0x00, 
0x00, 0x00, 0x70, 0x00, 0x70, 0x00, 
0x00, 0x04, 0x60, 0x00, 0x30, 0x00, 
0x00, 0x7f, 0xe0, 0x00, 0x30, 0x00, 
0x00, 0xfb, 0xc0, 0x00, 0x30, 0x00, 
0x03, 0xc0, 0x40, 0x00, 0x10, 0x00, 
0x03, 0x00, 0x00, 0x00, 0x3c, 0x00, 
0x06, 0x00, 0x00, 0x00, 0x3f, 0x80, 
0x0e, 0x00, 0x00, 0xc0, 0x03, 0xc0, 
0x0c, 0x00, 0x00, 0xc0, 0x00, 0xe0, 
0x0c, 0x00, 0x01, 0xe0, 0x00, 0x60, 
0x0c, 0x00, 0x01, 0xe0, 0x00, 0x30, 
0x0c, 0x00, 0x3c, 0xcf, 0x00, 0x30, 
0x0c, 0x00, 0x7c, 0xcf, 0x00, 0x30, 
0x0c, 0x00, 0x3e, 0xdf, 0x00, 0x30, 
0x0e, 0x00, 0x3f, 0xff, 0x00, 0x30, 
0x06, 0x00, 0x03, 0xf0, 0x00, 0x30, 
0x07, 0x00, 0x03, 0xf0, 0x00, 0x60, 
0x03, 0x80, 0x3f, 0xff, 0x00, 0xe0, 
0x01, 0xe0, 0x3e, 0xdf, 0x03, 0xc0, 
0x00, 0x7c, 0x7c, 0xcf, 0x8f, 0x80, 
0x00, 0x1c, 0x2c, 0xcd, 0x0e, 0x00, 
0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 
0x00, 0xc0, 0x00, 0xc0, 0x00, 0x00, 
0x03, 0xc0, 0x00, 0x00, 0x01, 0x80, 
0x03, 0xe0, 0x00, 0x00, 0x0f, 0x80, 
0x01, 0xf0, 0x00, 0x00, 0x07, 0xc0, 
0x01, 0x80, 0x01, 0x00, 0x03, 0xc0, 
0x00, 0x00, 0x01, 0x80, 0x03, 0x00, 
0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 
0x00, 0x02, 0x07, 0xc0, 0x40, 0x00, 
0x00, 0x16, 0x06, 0x02, 0xc0, 0x00, 
0x00, 0x1e, 0x00, 0x03, 0xc0, 0x00, 
0x00, 0x0f, 0x00, 0x01, 0xe0, 0x00, 
0x00, 0x0f, 0x00, 0x01, 0xe0, 0x00, 
0x00, 0x0c, 0x00, 0x01, 0x80, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t sunny [288] {
0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 
0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 
0x00, 0x0c, 0x03, 0xc0, 0x30, 0x00, 
0x00, 0x1e, 0x03, 0xc0, 0x78, 0x00, 
0x00, 0x1f, 0x03, 0xc0, 0xf8, 0x00, 
0x00, 0x0f, 0x03, 0xc0, 0xf0, 0x00, 
0x00, 0x0f, 0x83, 0xc1, 0xf0, 0x00, 
0x00, 0x07, 0x81, 0x81, 0xe0, 0x00, 
0x00, 0x07, 0xc0, 0x03, 0xe0, 0x00, 
0x00, 0x03, 0x80, 0x01, 0xc0, 0x00, 
0x0c, 0x01, 0x07, 0xe0, 0x80, 0x30, 
0x1f, 0x00, 0x3f, 0xfc, 0x00, 0xf8, 
0x1f, 0xc0, 0xff, 0xff, 0x03, 0xf8, 
0x0f, 0xe1, 0xff, 0xff, 0x87, 0xf0, 
0x07, 0xf3, 0xf8, 0x1f, 0xcf, 0xe0, 
0x01, 0xe7, 0xe0, 0x07, 0xe7, 0x80, 
0x00, 0x47, 0xc0, 0x03, 0xe2, 0x00, 
0x00, 0x0f, 0x80, 0x01, 0xf0, 0x00, 
0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 
0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 
0x00, 0x1e, 0x00, 0x00, 0x78, 0x00, 
0x7f, 0x1e, 0x00, 0x00, 0x78, 0xfe, 
0xff, 0x9e, 0x00, 0x00, 0x79, 0xff, 
0xff, 0x9e, 0x00, 0x00, 0x79, 0xff, 
0x7f, 0x1e, 0x00, 0x00, 0x78, 0xfe, 
0x00, 0x1e, 0x00, 0x00, 0x78, 0x00, 
0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 
0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 
0x00, 0x0f, 0x80, 0x01, 0xf0, 0x00, 
0x00, 0x47, 0xc0, 0x03, 0xe2, 0x00, 
0x01, 0xe7, 0xe0, 0x07, 0xe7, 0x80, 
0x07, 0xf3, 0xf8, 0x1f, 0xcf, 0xe0, 
0x0f, 0xe1, 0xff, 0xff, 0x87, 0xf0, 
0x1f, 0xc0, 0xff, 0xff, 0x03, 0xf8, 
0x1f, 0x00, 0x3f, 0xfc, 0x00, 0xf8, 
0x0c, 0x01, 0x07, 0xe0, 0x80, 0x30, 
0x00, 0x03, 0x80, 0x01, 0xc0, 0x00, 
0x00, 0x07, 0xc0, 0x03, 0xe0, 0x00, 
0x00, 0x07, 0x81, 0x81, 0xe0, 0x00, 
0x00, 0x0f, 0x83, 0xc1, 0xf0, 0x00, 
0x00, 0x0f, 0x03, 0xc0, 0xf0, 0x00, 
0x00, 0x1f, 0x03, 0xc0, 0xf8, 0x00, 
0x00, 0x1e, 0x03, 0xc0, 0x78, 0x00, 
0x00, 0x0c, 0x03, 0xc0, 0x30, 0x00, 
0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 
0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x80, 0x00, 0x00
};

void OLED::oled_draw_logo()
{
	m_display->clearDisplay();
	Serial.print("Drawing: ");
	Serial.println(oled_scroll_counter);
	switch (oled_scroll_counter)
	{
	case 0:
		m_display->drawBitmap(0, 0, logo_ordered_dither, 128, 64, SSD1306_WHITE);
		break;
	case 1:
		m_display->drawBitmap(0, 16, thunder_cloud, 48, 48, SSD1306_WHITE);
		break;
	case 2:
		m_display->drawBitmap(0, 16, snow_cloudy, 48, 48, SSD1306_WHITE);
	break;
	case 3:
		m_display->drawBitmap(0, 16, partly_cloudy, 48, 48, SSD1306_WHITE);
	break;
	case 4:
		m_display->drawBitmap(0, 16, sunny, 48, 48, SSD1306_WHITE);
	break;
	default:
		m_display->drawBitmap(0, 0, logo_ordered_dither, 128, 64, SSD1306_WHITE);
		break;
	}
	// Copy image_avnet to OLED buffer
	// Send the buffer to OLED RAM
	m_display->display();
}
